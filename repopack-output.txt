This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-23T17:40:34.440Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
config/___init__.py
config/settings.py
README.md
requirements.txt
src/__init__.py
src/analysis/__init__.py
src/analysis/fundamental.py
src/analysis/risk.py
src/analysis/sentiment.py
src/analysis/technical.py
src/models/__init__.py
src/models/database.py
src/pages/00_ðŸ _Home.py
src/pages/01_ðŸ“ˆ_Technical.py
src/pages/02_ðŸ“Š_Fundamental.py
src/pages/03_âš ï¸_Risk.py
src/pages/04_ðŸ“°_News.py
src/utils/__init__.py
src/utils/cache.py
src/utils/helpers.py

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual Environment
venv/
ENV/

# Environment Variables
.env
.env.*
!.env.example

# IDE
.idea/
.vscode/
*.swp
*.swo

# Streamlit
.streamlit/secrets.toml

# Data and Logs
*.log
logs/
data/
*.csv
*.xlsx
*.db
*.sqlite3

# Cache
__pycache__/
.ipynb_checkpoints/
.pytest_cache/
.coverage
htmlcov/

================
File: config/___init__.py
================
from .settings import Settings

settings = Settings()

================
File: config/settings.py
================
from pydantic_settings import BaseSettings
from typing import Dict, Any
import streamlit as st

class Settings(BaseSettings):
    # Data update intervals (in seconds)
    MARKET_DATA_UPDATE_INTERVAL: int = 60
    TECHNICAL_UPDATE_INTERVAL: int = 300
    FUNDAMENTAL_UPDATE_INTERVAL: int = 3600
    NEWS_UPDATE_INTERVAL: int = 300

    # Technical Analysis Settings
    TECHNICAL_INDICATORS: Dict[str, Any] = {
        'moving_averages': [20, 50, 200],
        'rsi': {'period': 14, 'overbought': 70, 'oversold': 30},
        'macd': {'fast': 12, 'slow': 26, 'signal': 9},
        'bollinger_bands': {'period': 20, 'std_dev': 2}
    }

    # Fundamental Analysis Settings
    FUNDAMENTAL_METRICS: Dict[str, Any] = {
        'growth_metrics': ['Revenue', 'EBITDA', 'Net Income'],
        'valuation_metrics': ['P/E', 'EV/EBITDA', 'P/B'],
        'profitability_metrics': ['Gross Margin', 'Operating Margin', 'Net Margin'],
        'liquidity_metrics': ['Current Ratio', 'Quick Ratio', 'Cash Ratio']
    }

    # Risk Analysis Settings
    RISK_METRICS: Dict[str, Any] = {
        'var_confidence_level': 0.95,
        'var_time_horizon': 10,
        'correlation_lookback': 252,
        'volatility_window': 252
    }

    # Sentiment Analysis Settings
    SENTIMENT_SETTINGS: Dict[str, Any] = {
        'news_lookback_days': 30,
        'min_article_length': 100,
        'sentiment_thresholds': {
            'very_positive': 0.6,
            'positive': 0.2,
            'neutral': -0.2,
            'negative': -0.6
        }
    }

    # Cache Settings
    CACHE_SETTINGS: Dict[str, Any] = {
        'market_data_ttl': 3600,
        'technical_analysis_ttl': 3600,
        'fundamental_analysis_ttl': 86400,
        'news_ttl': 3600
    }

    # API Rate Limits (requests per minute)
    RATE_LIMITS: Dict[str, int] = {
        'finnhub': 60,
        'polygon': 5,
        'alpha_vantage': 5,
        'news_api': 10
    }

    class Config:
        env_file = '.env'
        case_sensitive = True

    @property
    def api_keys(self) -> Dict[str, str]:
        """Get API keys from Streamlit secrets."""
        return {
            'anthropic': st.secrets['ANTHROPIC_API_KEY'],
            'finnhub': st.secrets['FINNHUB_API_KEY'],
            'polygon': st.secrets['POLYGON_API_KEY'],
            'alpha_vantage': st.secrets['ALPHA_VANTAGE_API_KEY'],
            'news_api': st.secrets['NEWS_API_KEY']
        }

    def get_indicator_settings(self, indicator: str) -> Dict[str, Any]:
        """Get settings for specific technical indicator."""
        return self.TECHNICAL_INDICATORS.get(indicator, {})

    def get_cache_ttl(self, data_type: str) -> int:
        """Get cache TTL for specific data type."""
        return self.CACHE_SETTINGS.get(f'{data_type}_ttl', 3600)

    def get_rate_limit(self, api: str) -> int:
        """Get rate limit for specific API."""
        return self.RATE_LIMITS.get(api, 1)

================
File: README.md
================
# Investment Analysis Dashboard

A comprehensive financial analysis system built with Streamlit, providing real-time market data, technical analysis, fundamental analysis, and AI-powered insights.

## Features

- Real-time market data tracking
- Technical analysis with multiple indicators
- Fundamental analysis using financial statements
- Sentiment analysis using news and social media
- Risk metrics and portfolio analysis
- Stock screening capabilities

## Quick Start

1. Clone the repository:
```bash
git clone https://github.com/yourusername/investment-analysis.git
cd investment-analysis
```

2. Create and activate virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

4. Set up your environment variables:
```bash
cp .env.example .env
# Edit .env with your API keys
```

5. Run the dashboard:
```bash
streamlit run src/pages/00_ðŸ _Home.py
```

## API Keys Required

- Anthropic (Claude AI)
- Finnhub
- Polygon.io
- Alpha Vantage
- News API

## Project Structure

```
investment-analysis/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ data/         # Data collection modules
â”‚   â”œâ”€â”€ analysis/     # Analysis modules
â”‚   â”œâ”€â”€ utils/        # Utility functions
â”‚   â””â”€â”€ pages/        # Streamlit pages
```

## Pages

1. ðŸ  Home: Overview dashboard
2. ðŸ“ˆ Technical: Technical analysis
3. ðŸ“Š Fundamental: Fundamental analysis
4. âš ï¸ Risk: Risk metrics
5. ðŸ“° News: News and sentiment
6. ðŸ” Screening: Stock screening

## Usage

### Market Data
```python
from src.data.market_data import MarketDataLoader

# Initialize loader
loader = MarketDataLoader()

# Get market data
data = loader.get_market_data("AAPL", "1y")
```

### Technical Analysis
```python
from src.analysis.technical import TechnicalAnalyzer

# Initialize analyzer
analyzer = TechnicalAnalyzer()

# Get analysis
analysis = analyzer.analyze_price_action(data)
```

### Fundamental Analysis
```python
from src.analysis.fundamental import FundamentalAnalyzer

# Initialize analyzer
analyzer = FundamentalAnalyzer()

# Get analysis
analysis = analyzer.analyze_company("AAPL")
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

Distributed under the MIT License. See `LICENSE` for more information.

================
File: requirements.txt
================
# Core
streamlit==1.31.0
pandas==2.1.4
numpy==1.26.3
python-dotenv==1.0.0

# Data Sources
yfinance==0.2.35
finnhub-python==2.4.19
polygon-api-client==1.12.3
alpha_vantage==2.3.1
newsapi-python==0.2.7

# Analysis
plotly==5.18.0
ta-lib==0.4.28
scikit-learn==1.3.2
tensorflow==2.15.0
anthropic==0.8.1
textblob==0.17.1

# Data Processing
pandas-ta==0.3.14b0
beautifulsoup4==4.12.3
requests==2.31.0
python-dateutil==2.8.2

# Utilities
streamlit-autorefresh==1.0.1
streamlit-option-menu==0.3.6

================
File: src/__init__.py
================
from .data import MarketDataLoader, FinancialDataLoader, NewsDataLoader
from .analysis import AnalysisManager, TechnicalAnalyzer, FundamentalAnalyzer, RiskAnalyzer, SentimentAnalyzer
from .models import DatabaseManager
from .utils import CacheManager, DataProcessing, FormatHelper, TimeHelper

__version__ = '1.0.0'

__all__ = [
    'MarketDataLoader',
    'FinancialDataLoader',
    'NewsDataLoader',
    'AnalysisManager',
    'TechnicalAnalyzer',
    'FundamentalAnalyzer',
    'RiskAnalyzer',
    'SentimentAnalyzer',
    'DatabaseManager',
    'CacheManager',
    'DataProcessing',
    'FormatHelper',
    'TimeHelper'
]

================
File: src/analysis/__init__.py
================
from .technical import TechnicalAnalyzer
from .fundamental import FundamentalAnalyzer
from .risk import RiskAnalyzer
from .sentiment import SentimentAnalyzer
from typing import Dict, List, Any
import pandas as pd
import streamlit as st

class AnalysisManager:
    """Manager class to coordinate different types of analysis."""
    
    def __init__(self):
        self.technical = TechnicalAnalyzer()
        self.fundamental = FundamentalAnalyzer()
        self.risk = RiskAnalyzer()
        self.sentiment = SentimentAnalyzer()
    
    def perform_complete_analysis(self, ticker: str, 
                                market_data: pd.DataFrame,
                                news_data: List[Dict],
                                financial_reports: Dict[str, Any]) -> Dict[str, Any]:
        """Perform comprehensive analysis using all analyzers."""
        try:
            # Technical Analysis
            technical_analysis = self.technical.analyze_price_action(market_data)
            
            # Fundamental Analysis
            fundamental_analysis = self.fundamental.analyze_company(ticker)
            
            # Risk Analysis
            risk_analysis = self.risk.calculate_risk_metrics(market_data)
            
            # Sentiment Analysis
            sentiment_analysis = self.sentiment.analyze_sentiment(
                ticker, 
                news_data, 
                financial_reports
            )
            
            return {
                'technical': technical_analysis,
                'fundamental': fundamental_analysis,
                'risk': risk_analysis,
                'sentiment': sentiment_analysis,
                'summary': self._generate_summary(
                    technical_analysis,
                    fundamental_analysis,
                    risk_analysis,
                    sentiment_analysis
                )
            }
        except Exception as e:
            st.error(f"Error in complete analysis: {str(e)}")
            return {}
    
    def _generate_summary(self, technical: Dict[str, Any],
                         fundamental: Dict[str, Any],
                         risk: Dict[str, Any],
                         sentiment: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a summary of all analyses."""
        try:
            return {
                'overall_rating': self._calculate_overall_rating(
                    technical, fundamental, risk, sentiment
                ),
                'key_findings': self._extract_key_findings(
                    technical, fundamental, risk, sentiment
                ),
                'recommendations': self._generate_recommendations(
                    technical, fundamental, risk, sentiment
                )
            }
        except Exception as e:
            st.error(f"Error generating summary: {str(e)}")
            return {}
    
    def _calculate_overall_rating(self, *analyses) -> str:
        """Calculate overall investment rating."""
        try:
            # Implement rating logic based on all analyses
            scores = {
                'technical': self._score_technical(analyses[0]),
                'fundamental': self._score_fundamental(analyses[1]),
                'risk': self._score_risk(analyses[2]),
                'sentiment': self._score_sentiment(analyses[3])
            }
            
            total_score = sum(scores.values()) / len(scores)
            
            if total_score >= 8:
                return "Strong Buy"
            elif total_score >= 6:
                return "Buy"
            elif total_score >= 4:
                return "Hold"
            elif total_score >= 2:
                return "Sell"
            else:
                return "Strong Sell"
        except Exception as e:
            st.error(f"Error calculating overall rating: {str(e)}")
            return "N/A"
    
    def _score_technical(self, analysis: Dict[str, Any]) -> float:
        """Score technical analysis results."""
        score = 5.0  # Neutral starting point
        if not analysis:
            return score
            
        try:
            # Adjust score based on technical signals
            if analysis.get('trends', {}).get('overall', {}).get('direction') == 'bullish':
                score += 1
            elif analysis.get('trends', {}).get('overall', {}).get('direction') == 'bearish':
                score -= 1
                
            # Add momentum impact
            momentum = analysis.get('momentum', {}).get('macd', {})
            if momentum.get('trend') == 'bullish':
                score += 1
            elif momentum.get('trend') == 'bearish':
                score -= 1
                
            return min(max(score, 0), 10)  # Ensure score is between 0 and 10
        except:
            return score
            
    def _score_fundamental(self, analysis: Dict[str, Any]) -> float:
        """Score fundamental analysis results."""
        score = 5.0
        if not analysis:
            return score
            
        try:
            # Adjust score based on fundamental factors
            profitability = analysis.get('profitability', {})
            growth = analysis.get('growth', {})
            
            # Profitability impact
            # Profitability impact
            if profitability.get('net_margin', 0) > 0.15:
                score += 1
            elif profitability.get('net_margin', 0) < 0:
                score -= 1
                
            # Growth impact
            revenue_growth = growth.get('revenue_growth', 0)
            if revenue_growth > 20:
                score += 2
            elif revenue_growth > 10:
                score += 1
            elif revenue_growth < 0:
                score -= 1
                
            return min(max(score, 0), 10)
        except:
            return score
    
    def _score_risk(self, analysis: Dict[str, Any]) -> float:
        """Score risk analysis results."""
        score = 5.0
        if not analysis:
            return score
            
        try:
            # Adjust score based on risk metrics
            volatility = analysis.get('volatility', {})
            var = analysis.get('value_at_risk', {})
            
            # Volatility impact
            if volatility.get('annual_volatility', 0) > 0.4:
                score -= 2
            elif volatility.get('annual_volatility', 0) > 0.25:
                score -= 1
                
            # VaR impact
            if var.get('historical_var', 0) < -0.1:
                score -= 1
                
            # Beta impact
            beta = analysis.get('beta', {}).get('beta', 1)
            if beta > 1.5:
                score -= 1
            elif beta < 0.8:
                score += 1
                
            return min(max(score, 0), 10)
        except:
            return score
    
    def _score_sentiment(self, analysis: Dict[str, Any]) -> float:
        """Score sentiment analysis results."""
        score = 5.0
        if not analysis:
            return score
            
        try:
            # Overall sentiment impact
            sentiment_score = analysis.get('overall_sentiment', 0)
            if sentiment_score > 0.5:
                score += 2
            elif sentiment_score > 0.2:
                score += 1
            elif sentiment_score < -0.2:
                score -= 1
            elif sentiment_score < -0.5:
                score -= 2
                
            # News sentiment trend
            trend = analysis.get('sentiment_trends', {}).get('trend')
            if trend == 'improving':
                score += 1
            elif trend == 'deteriorating':
                score -= 1
                
            return min(max(score, 0), 10)
        except:
            return score
    
    def _extract_key_findings(self, technical: Dict[str, Any],
                            fundamental: Dict[str, Any],
                            risk: Dict[str, Any],
                            sentiment: Dict[str, Any]) -> List[str]:
        """Extract key findings from all analyses."""
        findings = []
        
        try:
            # Technical findings
            if technical.get('trends', {}).get('overall', {}).get('direction'):
                findings.append(f"Technical Trend: {technical['trends']['overall']['direction']}")
                
            # Fundamental findings
            if fundamental.get('growth', {}).get('revenue_growth'):
                findings.append(
                    f"Revenue Growth: {fundamental['growth']['revenue_growth']:.1f}%"
                )
                
            # Risk findings
            if risk.get('volatility', {}).get('annual_volatility'):
                findings.append(
                    f"Annual Volatility: {risk['volatility']['annual_volatility']:.1%}"
                )
                
            # Sentiment findings
            if sentiment.get('overall_sentiment'):
                findings.append(
                    f"Market Sentiment: {self._classify_sentiment(sentiment['overall_sentiment'])}"
                )
                
            return findings
        except Exception as e:
            st.error(f"Error extracting key findings: {str(e)}")
            return []
    
    def _generate_recommendations(self, technical: Dict[str, Any],
                                fundamental: Dict[str, Any],
                                risk: Dict[str, Any],
                                sentiment: Dict[str, Any]) -> Dict[str, List[str]]:
        """Generate actionable recommendations."""
        try:
            recommendations = {
                'action': [],
                'watch_points': [],
                'risk_management': []
            }
            
            # Technical-based recommendations
            tech_trend = technical.get('trends', {}).get('overall', {}).get('direction')
            if tech_trend == 'bullish':
                recommendations['action'].append("Consider entry points on pullbacks")
            elif tech_trend == 'bearish':
                recommendations['action'].append("Consider reducing position size")
            
            # Fundamental-based recommendations
            growth = fundamental.get('growth', {}).get('revenue_growth', 0)
            margins = fundamental.get('profitability', {}).get('net_margin', 0)
            if growth > 20 and margins > 0.15:
                recommendations['action'].append("Consider long-term position building")
            elif growth < 0 or margins < 0:
                recommendations['action'].append("Review fundamental factors before adding")
            
            # Risk-based recommendations
            volatility = risk.get('volatility', {}).get('annual_volatility', 0)
            if volatility > 0.3:
                recommendations['risk_management'].append(
                    f"Consider position sizing due to high volatility ({volatility:.1%})"
                )
            
            var = risk.get('value_at_risk', {}).get('historical_var', 0)
            recommendations['risk_management'].append(
                f"Set stop loss considering VaR: {var:.1%}"
            )
            
            # Sentiment-based recommendations
            sentiment_score = sentiment.get('overall_sentiment', 0)
            if sentiment_score > 0.5:
                recommendations['watch_points'].append("Monitor for potential profit taking")
            elif sentiment_score < -0.5:
                recommendations['watch_points'].append("Watch for sentiment reversal")
            
            return recommendations
        except Exception as e:
            st.error(f"Error generating recommendations: {str(e)}")
            return {'action': [], 'watch_points': [], 'risk_management': []}
    
    def _classify_sentiment(self, sentiment_score: float) -> str:
        """Classify sentiment score into categories."""
        if sentiment_score > 0.5:
            return "Very Positive"
        elif sentiment_score > 0.2:
            return "Positive"
        elif sentiment_score > -0.2:
            return "Neutral"
        elif sentiment_score > -0.5:
            return "Negative"
        else:
            return "Very Negative"

# Export all analyzers and manager
__all__ = [
    'TechnicalAnalyzer',
    'FundamentalAnalyzer',
    'RiskAnalyzer',
    'SentimentAnalyzer',
    'AnalysisManager'
]

================
File: src/analysis/fundamental.py
================
import pandas as pd
import numpy as np
from typing import Dict, Any, List
import streamlit as st
from src.data.financial_data import FinancialDataLoader

class FundamentalAnalyzer:
    def __init__(self):
        self.financial_loader = FinancialDataLoader()
        
    @st.cache_data(ttl=86400)  # Cache for 1 day
    def analyze_company(self, ticker: str) -> Dict[str, Any]:
        """Perform comprehensive fundamental analysis."""
        try:
            # Get financial data
            financials = self.financial_loader.get_financial_statements(ticker)
            
            analysis = {
                'profitability': self._analyze_profitability(financials),
                'efficiency': self._analyze_efficiency(financials),
                'liquidity': self._analyze_liquidity(financials),
                'solvency': self._analyze_solvency(financials),
                'growth': self._analyze_growth(financials),
                'valuation': self._analyze_valuation(financials),
                'dupont': self._dupont_analysis(financials),
                'cash_flows': self._analyze_cash_flows(financials)
            }
            
            return analysis
        except Exception as e:
            st.error(f"Error in fundamental analysis: {str(e)}")
            return {}

    def _analyze_profitability(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Analyze profitability metrics."""
        try:
            income_stmt = financials['income_statement']
            
            return {
                'gross_margin': self._calculate_ratio(
                    income_stmt['Gross Profit'],
                    income_stmt['Total Revenue']
                ),
                'operating_margin': self._calculate_ratio(
                    income_stmt['Operating Income'],
                    income_stmt['Total Revenue']
                ),
                'net_margin': self._calculate_ratio(
                    income_stmt['Net Income'],
                    income_stmt['Total Revenue']
                ),
                'roa': self._calculate_return_on_assets(financials),
                'roe': self._calculate_return_on_equity(financials)
            }
        except Exception as e:
            st.error(f"Error analyzing profitability: {str(e)}")
            return {}

    def _analyze_efficiency(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Analyze operational efficiency metrics."""
        try:
            balance = financials['balance_sheet']
            income = financials['income_statement']
            
            return {
                'asset_turnover': self._calculate_ratio(
                    income['Total Revenue'],
                    balance['Total Assets'].mean()
                ),
                'inventory_turnover': self._calculate_inventory_turnover(financials),
                'receivables_turnover': self._calculate_receivables_turnover(financials),
                'payables_turnover': self._calculate_payables_turnover(financials),
                'cash_conversion_cycle': self._calculate_cash_conversion_cycle(financials)
            }
        except Exception as e:
            st.error(f"Error analyzing efficiency: {str(e)}")
            return {}

    def _analyze_liquidity(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Analyze liquidity metrics."""
        try:
            balance = financials['balance_sheet']
            
            return {
                'current_ratio': self._calculate_ratio(
                    balance['Current Assets'],
                    balance['Current Liabilities']
                ),
                'quick_ratio': self._calculate_quick_ratio(balance),
                'cash_ratio': self._calculate_ratio(
                    balance['Cash and Cash Equivalents'],
                    balance['Current Liabilities']
                ),
                'working_capital': (
                    balance['Current Assets'] - balance['Current Liabilities']
                ).iloc[0]
            }
        except Exception as e:
            st.error(f"Error analyzing liquidity: {str(e)}")
            return {}

    def _analyze_solvency(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Analyze solvency and leverage metrics."""
        try:
            balance = financials['balance_sheet']
            income = financials['income_statement']
            
            return {
                'debt_to_equity': self._calculate_ratio(
                    balance['Total Liabilities'],
                    balance['Total Stockholder Equity']
                ),
                'debt_to_assets': self._calculate_ratio(
                    balance['Total Liabilities'],
                    balance['Total Assets']
                ),
                'interest_coverage': self._calculate_ratio(
                    income['Operating Income'],
                    income['Interest Expense']
                ),
                'equity_multiplier': self._calculate_ratio(
                    balance['Total Assets'],
                    balance['Total Stockholder Equity']
                )
            }
        except Exception as e:
            st.error(f"Error analyzing solvency: {str(e)}")
            return {}

    def _analyze_growth(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Analyze growth rates."""
        try:
            income = financials['income_statement']
            balance = financials['balance_sheet']
            
            return {
                'revenue_growth': self._calculate_growth_rate(income['Total Revenue']),
                'net_income_growth': self._calculate_growth_rate(income['Net Income']),
                'eps_growth': self._calculate_growth_rate(income['EPS']),
                'asset_growth': self._calculate_growth_rate(balance['Total Assets']),
                'equity_growth': self._calculate_growth_rate(balance['Total Stockholder Equity'])
            }
        except Exception as e:
            st.error(f"Error analyzing growth: {str(e)}")
            return {}

    def _analyze_valuation(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Calculate valuation metrics."""
        try:
            info = financials['info']
            income = financials['income_statement']
            balance = financials['balance_sheet']
            
            market_cap = info.get('marketCap', 0)
            enterprise_value = self._calculate_enterprise_value(market_cap, balance)
            
            return {
                'pe_ratio': info.get('trailingPE', 0),
                'forward_pe': info.get('forwardPE', 0),
                'price_to_book': self._calculate_ratio(
                    market_cap,
                    balance['Total Stockholder Equity'].iloc[0]
                ),
                'ev_to_ebitda': self._calculate_ratio(
                    enterprise_value,
                    income['EBITDA'].iloc[0]
                ),
                'peg_ratio': info.get('pegRatio', 0),
                'dividend_yield': info.get('dividendYield', 0) * 100
            }
        except Exception as e:
            st.error(f"Error analyzing valuation: {str(e)}")
            return {}

    def _analyze_cash_flows(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Analyze cash flow metrics."""
        try:
            cash_flow = financials['cash_flow']
            income = financials['income_statement']
            
            return {
                'operating_cash_flow_ratio': self._calculate_ratio(
                    cash_flow['Operating Cash Flow'],
                    income['Net Income']
                ),
                'free_cash_flow': self._calculate_fcf(cash_flow),
                'fcf_yield': self._calculate_fcf_yield(cash_flow, financials['info']),
                'capex_to_revenue': self._calculate_ratio(
                    cash_flow['Capital Expenditures'],
                    income['Total Revenue']
                )
            }
        except Exception as e:
            st.error(f"Error analyzing cash flows: {str(e)}")
            return {}

    def _dupont_analysis(self, financials: Dict[str, pd.DataFrame]) -> Dict[str, Any]:
        """Perform DuPont analysis."""
        try:
            income = financials['income_statement']
            balance = financials['balance_sheet']
            
            net_margin = self._calculate_ratio(
                income['Net Income'],
                income['Total Revenue']
            )
            
            asset_turnover = self._calculate_ratio(
                income['Total Revenue'],
                balance['Total Assets'].mean()
            )
            
            leverage = self._calculate_ratio(
                balance['Total Assets'],
                balance['Total Stockholder Equity']
            )
            
            return {
                'net_margin': net_margin,
                'asset_turnover': asset_turnover,
                'leverage': leverage,
                'roe_decomposition': {
                    'net_margin': net_margin,
                    'asset_turnover': asset_turnover,
                    'leverage': leverage,
                    'roe': net_margin * asset_turnover * leverage
                }
            }
        except Exception as e:
            st.error(f"Error in DuPont analysis: {str(e)}")
            return {}

    # Helper methods
    def _calculate_ratio(self, numerator: pd.Series, denominator: pd.Series) -> float:
        """Calculate financial ratio safely."""
        try:
            if denominator.iloc[0] != 0:
                return numerator.iloc[0] / denominator.iloc[0]
            return 0
        except:
            return 0

    def _calculate_growth_rate(self, series: pd.Series) -> float:
        """Calculate year-over-year growth rate."""
        try:
            if len(series) >= 2:
                return ((series.iloc[0] / series.iloc[1]) - 1) * 100
            return 0
        except:
            return 0

    def _calculate_quick_ratio(self, balance: pd.DataFrame) -> float:
        """Calculate quick ratio (acid-test ratio)."""
        try:
            quick_assets = (
                balance['Current Assets'].iloc[0] -
                balance['Inventory'].iloc[0]
            )
            return quick_assets / balance['Current Liabilities'].iloc[0]
        except:
            return 0

    def _calculate_enterprise_value(self, market_cap: float, balance: pd.DataFrame) -> float:
        """Calculate enterprise value."""
        try:
            return (
                market_cap +
                balance['Total Debt'].iloc[0] -
                balance['Cash and Cash Equivalents'].iloc[0]
            )
        except:
            return 0

    def _calculate_fcf(self, cash_flow: pd.DataFrame) -> float:
        """Calculate Free Cash Flow."""
        try:
            return (
                cash_flow['Operating Cash Flow'].iloc[0] -
                cash_flow['Capital Expenditures'].iloc[0]
            )
        except:
            return 0

    def _calculate_fcf_yield(self, cash_flow: pd.DataFrame, info: Dict[str, Any]) -> float:
        """Calculate Free Cash Flow Yield."""
        try:
            fcf = self._calculate_fcf(cash_flow)
            market_cap = info.get('marketCap', 0)
            if market_cap > 0:
                return (fcf / market_cap) * 100
            return 0
        except:
            return 0

    def generate_analysis_report(self, analysis: Dict[str, Any]) -> str:
        """Generate a comprehensive analysis report."""
        try:
            report = f"""
            Fundamental Analysis Report
            
            1. Profitability Metrics:
            - Gross Margin: {analysis['profitability']['gross_margin']:.2%}
            - Operating Margin: {analysis['profitability']['operating_margin']:.2%}
            - Net Margin: {analysis['profitability']['net_margin']:.2%}
            - ROE: {analysis['profitability']['roe']:.2%}
            - ROA: {analysis['profitability']['roa']:.2%}
            
            2. Growth Analysis:
            - Revenue Growth: {analysis['growth']['revenue_growth']:.2f}%
            - Net Income Growth: {analysis['growth']['net_income_growth']:.2f}%
            - EPS Growth: {analysis['growth']['eps_growth']:.2f}%
            
            3. Valuation Metrics:
            - P/E Ratio: {analysis['valuation']['pe_ratio']:.2f}
            - Forward P/E: {analysis['valuation']['forward_pe']:.2f}
            - P/B Ratio: {analysis['valuation']['price_to_book']:.2f}
            - EV/EBITDA: {analysis['valuation']['ev_to_ebitda']:.2f}
            
            4. Financial Health:
            - Current Ratio: {analysis['liquidity']['current_ratio']:.2f}
            - Debt to Equity: {analysis['solvency']['debt_to_equity']:.2f}
            - Interest Coverage: {analysis['solvency']['interest_coverage']:.2f}
            
            5. Cash Flow Analysis:
            - FCF Yield: {analysis['cash_flows']['fcf_yield']:.2f}%
            - Operating Cash Flow Ratio: {analysis['cash_flows']['operating_cash_flow_ratio']:.2f}
            """
            
            return report
        except Exception as e:
            st.error(f"Error generating analysis report: {str(e)}")
            return "Error generating analysis report."

================
File: src/analysis/risk.py
================
import pandas as pd
import numpy as np
from typing import Dict, Any
import streamlit as st
from scipy import stats
from scipy.stats import norm

class RiskAnalyzer:
    def __init__(self):
        self.confidence_level = 0.95
        self.time_horizon = 10
        
    @st.cache_data(ttl=3600)
    def calculate_risk_metrics(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Calculate comprehensive risk metrics for a stock."""
        returns = data['Close'].pct_change().dropna()
        
        risk_metrics = {
            'volatility': self._calculate_volatility(returns),
            'value_at_risk': self._calculate_var(returns),
            'beta': self._calculate_beta(returns),
            'drawdown': self._calculate_drawdown(data['Close']),
            'tail_risk': self._calculate_tail_risk(returns),
            'correlation': self._calculate_correlation(returns)
        }
        
        return risk_metrics
    
    def _calculate_volatility(self, returns: pd.Series) -> Dict[str, float]:
        """Calculate various volatility measures."""
        try:
            daily_vol = returns.std()
            annual_vol = daily_vol * np.sqrt(252)
            
            # Calculate rolling volatility
            rolling_vol = returns.rolling(window=30).std() * np.sqrt(252)
            
            # Estimate forward volatility using EWMA
            ewma_vol = returns.ewm(span=30).std() * np.sqrt(252)
            
            return {
                'daily_volatility': daily_vol,
                'annual_volatility': annual_vol,
                'current_rolling_vol': rolling_vol.iloc[-1],
                'forward_vol_estimate': ewma_vol.iloc[-1]
            }
        except Exception as e:
            st.error(f"Error calculating volatility: {str(e)}")
            return {}

    def _calculate_var(self, returns: pd.Series) -> Dict[str, float]:
        """Calculate Value at Risk metrics."""
        try:
            # Historical VaR
            hist_var = np.percentile(returns, (1 - self.confidence_level) * 100)
            
            # Parametric VaR
            mean = returns.mean()
            std = returns.std()
            param_var = norm.ppf(1 - self.confidence_level, mean, std)
            
            # Conditional VaR (Expected Shortfall)
            cvar = returns[returns <= hist_var].mean()
            
            var_metrics = {
                'historical_var': hist_var,
                'parametric_var': param_var,
                'conditional_var': cvar,
                'var_confidence': self.confidence_level,
                'time_horizon': self.time_horizon
            }
            
            return var_metrics
        except Exception as e:
            st.error(f"Error calculating VaR: {str(e)}")
            return {}

    def _calculate_beta(self, returns: pd.Series) -> Dict[str, float]:
        """Calculate beta and related market sensitivity metrics."""
        try:
            # Get market returns (S&P 500)
            import yfinance as yf
            market = yf.download('^GSPC', start=returns.index[0], end=returns.index[-1])
            market_returns = market['Close'].pct_change().dropna()
            
            # Calculate beta
            covar = returns.cov(market_returns)
            market_var = market_returns.var()
            beta = covar / market_var
            
            # Calculate R-squared
            correlation = returns.corr(market_returns)
            r_squared = correlation ** 2
            
            return {
                'beta': beta,
                'r_squared': r_squared,
                'correlation_with_market': correlation
            }
        except Exception as e:
            st.error(f"Error calculating beta: {str(e)}")
            return {}

    def _calculate_drawdown(self, prices: pd.Series) -> Dict[str, float]:
        """Calculate drawdown metrics."""
        try:
            # Calculate running maximum
            running_max = prices.expanding().max()
            drawdown = (prices - running_max) / running_max
            
            return {
                'current_drawdown': drawdown.iloc[-1],
                'max_drawdown': drawdown.min(),
                'avg_drawdown': drawdown.mean(),
                'drawdown_duration': self._calculate_drawdown_duration(drawdown)
            }
        except Exception as e:
            st.error(f"Error calculating drawdown: {str(e)}")
            return {}

    def _calculate_tail_risk(self, returns: pd.Series) -> Dict[str, float]:
        """Calculate tail risk metrics."""
        try:
            return {
                'skewness': returns.skew(),
                'kurtosis': returns.kurtosis(),
                'jarque_bera': stats.jarque_bera(returns)[0],
                'tail_ratio': abs(returns.quantile(0.99)) / abs(returns.quantile(0.01))
            }
        except Exception as e:
            st.error(f"Error calculating tail risk: {str(e)}")
            return {}

    def _calculate_correlation(self, returns: pd.Series) -> Dict[str, float]:
        """Calculate correlation with various market factors."""
        try:
            # Get returns for different market factors
            factors = {
                'SPY': 'S&P 500',
                'QQQ': 'NASDAQ',
                'IWM': 'Russell 2000',
                'VIX': 'Volatility Index'
            }
            
            correlations = {}
            for symbol, name in factors.items():
                try:
                    factor_data = yf.download(symbol, start=returns.index[0], end=returns.index[-1])
                    factor_returns = factor_data['Close'].pct_change().dropna()
                    correlations[name] = returns.corr(factor_returns)
                except:
                    continue
            
            return correlations
        except Exception as e:
            st.error(f"Error calculating correlations: {str(e)}")
            return {}

    def _calculate_drawdown_duration(self, drawdown: pd.Series) -> int:
        """Calculate the current drawdown duration in days."""
        try:
            # Find the last peak
            last_peak = drawdown[drawdown == 0].index[-1]
            return (drawdown.index[-1] - last_peak).days
        except:
            return 0

    def generate_risk_report(self, risk_metrics: Dict[str, Any]) -> str:
        """Generate a narrative risk report."""
        try:
            vol = risk_metrics['volatility']
            var = risk_metrics['value_at_risk']
            beta = risk_metrics['beta']
            
            report = f"""
            Risk Analysis Report:
            
            1. Volatility Analysis:
            - Annual Volatility: {vol['annual_volatility']:.2%}
            - Current Rolling Volatility: {vol['current_rolling_vol']:.2%}
            - Forward Volatility Estimate: {vol['forward_vol_estimate']:.2%}
            
            2. Value at Risk (VaR):
            - Historical VaR ({self.confidence_level*100}%): {var['historical_var']:.2%}
            - Conditional VaR: {var['conditional_var']:.2%}
            
            3. Market Sensitivity:
            - Beta: {beta['beta']:.2f}
            - R-Squared: {beta['r_squared']:.2f}
            - Market Correlation: {beta['correlation_with_market']:.2f}
            
            4. Drawdown Analysis:
            - Maximum Drawdown: {risk_metrics['drawdown']['max_drawdown']:.2%}
            - Current Drawdown: {risk_metrics['drawdown']['current_drawdown']:.2%}
            - Drawdown Duration: {risk_metrics['drawdown']['drawdown_duration']} days
            """
            
            return report
        except Exception as e:
            st.error(f"Error generating risk report: {str(e)}")
            return "Error generating risk report."

================
File: src/analysis/sentiment.py
================
import pandas as pd
from typing import Dict, Any, List
import streamlit as st
from datetime import datetime, timedelta
import numpy as np
from anthropic import Anthropic
from textblob import TextBlob
import re

class SentimentAnalyzer:
    def __init__(self):
        self.anthropic = Anthropic(api_key=st.secrets["ANTHROPIC_API_KEY"])
        self.sentiment_weights = {
            'news': 0.4,
            'social_media': 0.3,
            'financial_reports': 0.3
        }

    @st.cache_data(ttl=3600)
    def analyze_sentiment(self, ticker: str, news_data: List[Dict], 
                         financial_reports: Dict[str, Any]) -> Dict[str, Any]:
        """Perform comprehensive sentiment analysis."""
        try:
            # Analyze different sources
            news_sentiment = self._analyze_news_sentiment(news_data)
            social_sentiment = self._analyze_social_media_sentiment(ticker)
            report_sentiment = self._analyze_financial_reports_sentiment(financial_reports)
            
            # Combine sentiments
            combined_sentiment = self._combine_sentiment_scores(
                news_sentiment,
                social_sentiment,
                report_sentiment
            )
            
            return {
                'overall_sentiment': combined_sentiment,
                'news_sentiment': news_sentiment,
                'social_sentiment': social_sentiment,
                'report_sentiment': report_sentiment,
                'sentiment_trends': self._analyze_sentiment_trends(news_data),
                'key_topics': self._extract_key_topics(news_data)
            }
        except Exception as e:
            st.error(f"Error in sentiment analysis: {str(e)}")
            return {}

    def _analyze_news_sentiment(self, news_data: List[Dict]) -> Dict[str, Any]:
        """Analyze sentiment from news articles."""
        try:
            sentiments = []
            for article in news_data:
                # Combine title and content for analysis
                text = f"{article['title']} {article.get('description', '')}"
                
                # Get sentiment scores
                blob_sentiment = TextBlob(text).sentiment
                
                sentiments.append({
                    'date': article['published_at'],
                    'score': blob_sentiment.polarity,
                    'subjectivity': blob_sentiment.subjectivity,
                    'source': article['source'],
                    'title': article['title']
                })
            
            # Calculate aggregate metrics
            sentiment_df = pd.DataFrame(sentiments)
            
            return {
                'average_score': sentiment_df['score'].mean(),
                'sentiment_distribution': {
                    'positive': len(sentiment_df[sentiment_df['score'] > 0.2]),
                    'neutral': len(sentiment_df[(sentiment_df['score'] >= -0.2) & 
                                             (sentiment_df['score'] <= 0.2)]),
                    'negative': len(sentiment_df[sentiment_df['score'] < -0.2])
                },
                'source_analysis': self._analyze_sentiment_by_source(sentiment_df),
                'recent_sentiments': sentiments[:5]  # Most recent articles
            }
        except Exception as e:
            st.error(f"Error analyzing news sentiment: {str(e)}")
            return {}

    def _analyze_social_media_sentiment(self, ticker: str) -> Dict[str, Any]:
        """Analyze sentiment from social media sources."""
        try:
            # Placeholder for social media API integrations
            # Would typically include Twitter, Reddit, StockTwits, etc.
            
            return {
                'average_score': 0.0,
                'platform_scores': {
                    'twitter': 0.0,
                    'reddit': 0.0,
                    'stocktwits': 0.0
                },
                'mention_volume': {
                    'total': 0,
                    'positive': 0,
                    'negative': 0
                }
            }
        except Exception as e:
            st.error(f"Error analyzing social media sentiment: {str(e)}")
            return {}

    def _analyze_financial_reports_sentiment(self, reports: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze sentiment from financial reports using Claude."""
        try:
            if not reports:
                return {}
                
            # Prepare text for analysis
            report_text = self._prepare_report_text(reports)
            
            # Analyze with Claude
            prompt = f"""
            Please analyze the sentiment and tone of these financial report excerpts.
            Focus on:
            1. Management's confidence and outlook
            2. Risk factors and concerns
            3. Forward-looking statements
            4. Key strategic initiatives
            
            Text:
            {report_text}
            
            Provide a structured analysis with sentiment scores and key points.
            """
            
            response = self.anthropic.messages.create(
                model="claude-3-opus-20240229",
                temperature=0,
                max_tokens=1000,
                messages=[{
                    "role": "user",
                    "content": prompt
                }]
            )
            
            # Process Claude's response
            analysis = self._parse_claude_response(response.content)
            
            return analysis
        except Exception as e:
            st.error(f"Error analyzing financial reports sentiment: {str(e)}")
            return {}

    def _combine_sentiment_scores(self, news: Dict[str, Any], 
                                social: Dict[str, Any], 
                                reports: Dict[str, Any]) -> float:
        """Combine sentiment scores from different sources."""
        try:
            scores = {
                'news': news.get('average_score', 0) * self.sentiment_weights['news'],
                'social': social.get('average_score', 0) * self.sentiment_weights['social_media'],
                'reports': reports.get('sentiment_score', 0) * self.sentiment_weights['financial_reports']
            }
            
            return sum(scores.values())
        except Exception as e:
            st.error(f"Error combining sentiment scores: {str(e)}")
            return 0.0

    def _analyze_sentiment_trends(self, news_data: List[Dict]) -> Dict[str, Any]:
        """Analyze sentiment trends over time."""
        try:
            # Convert news data to DataFrame
            df = pd.DataFrame(news_data)
            df['date'] = pd.to_datetime(df['published_at'])
            df.set_index('date', inplace=True)
            
            # Calculate daily sentiment averages
            daily_sentiment = df.resample('D')['sentiment_score'].mean()
            
            return {
                'trend': self._calculate_trend(daily_sentiment),
                'volatility': daily_sentiment.std(),
                'momentum': self._calculate_sentiment_momentum(daily_sentiment)
            }
        except Exception as e:
            st.error(f"Error analyzing sentiment trends: {str(e)}")
            return {}

    def _extract_key_topics(self, news_data: List[Dict]) -> List[Dict[str, Any]]:
        """Extract and analyze key topics from news."""
        try:
            # Combine all text
            all_text = ' '.join([
                f"{article['title']} {article.get('description', '')}"
                for article in news_data
            ])
            
            # Use Claude to extract topics
            prompt = f"""
            Please identify the main topics and themes in these news articles.
            Focus on:
            1. Key business events
            2. Market factors
            3. Industry trends
            4. Company-specific news
            
            Text:
            {all_text}
            
            List the top themes with their frequency and significance.
            """
            
            response = self.anthropic.messages.create(
                model="claude-3-opus-20240229",
                temperature=0,
                max_tokens=500,
                messages=[{
                    "role": "user",
                    "content": prompt
                }]
            )
            
            # Process and structure topics
            topics = self._process_topics(response.content)
            
            return topics
        except Exception as e:
            st.error(f"Error extracting key topics: {str(e)}")
            return []

    def _analyze_sentiment_by_source(self, df: pd.DataFrame) -> Dict[str, Any]:
        """Analyze sentiment patterns by news source."""
        try:
            source_analysis = df.groupby('source').agg({
                'score': ['mean', 'std', 'count'],
                'subjectivity': 'mean'
            }).round(3)
            
            return source_analysis.to_dict()
        except Exception as e:
            st.error(f"Error analyzing sentiment by source: {str(e)}")
            return {}

    def _calculate_trend(self, series: pd.Series) -> str:
        """Calculate the trend direction of sentiment."""
        try:
            if len(series) < 2:
                return "neutral"
                
            slope = np.polyfit(range(len(series)), series.values, 1)[0]
            
            if slope > 0.01:
                return "improving"
            elif slope < -0.01:
                return "deteriorating"
            return "stable"
        except Exception as e:
            st.error(f"Error calculating trend: {str(e)}")
            return "neutral"

    def _calculate_sentiment_momentum(self, series: pd.Series) -> float:
        """Calculate sentiment momentum (rate of change)."""
        try:
            if len(series) < 5:
                return 0.0
                
            recent_avg = series[-5:].mean()
            older_avg = series[-10:-5].mean()
            
            return ((recent_avg - older_avg) / older_avg) * 100
        except Exception as e:
            st.error(f"Error calculating sentiment momentum: {str(e)}")
            return 0.0

    def _parse_claude_response(self, response: str) -> Dict[str, Any]:
        """Parse and structure Claude's analysis response."""
        try:
            # Extract sentiment score (assuming Claude provides a normalized score)
            score_match = re.search(r'sentiment score[:\s]+(-?\d+\.?\d*)', 
                                  response.lower())
            sentiment_score = float(score_match.group(1)) if score_match else 0.0
            
            # Extract key points
            key_points = re.findall(r'â€¢\s+([^â€¢\n]+)', response)
            
            return {
                'sentiment_score': sentiment_score,
                'key_points': key_points,
                'full_analysis': response
            }
        except Exception as e:
            st.error(f"Error parsing Claude response: {str(e)}")
            return {}

================
File: src/analysis/technical.py
================
import pandas as pd
import numpy as np
from typing import Dict, Any, List
import streamlit as st
import talib
from scipy import stats

class TechnicalAnalyzer:
    def __init__(self):
        self.ma_periods = [20, 50, 200]
        self.rsi_period = 14
        self.macd_params = {
            'fastperiod': 12,
            'slowperiod': 26,
            'signalperiod': 9
        }
        
    @st.cache_data(ttl=1800)  # 30 minutes cache
    def analyze_price_action(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Perform comprehensive technical analysis."""
        try:
            analysis = {
                'trends': self._analyze_trends(data),
                'momentum': self._analyze_momentum(data),
                'volatility': self._analyze_volatility(data),
                'volume': self._analyze_volume(data),
                'patterns': self._identify_patterns(data),
                'support_resistance': self._find_support_resistance(data),
                'signals': self._generate_signals(data)
            }
            return analysis
        except Exception as e:
            st.error(f"Error in technical analysis: {str(e)}")
            return {}

    def _analyze_trends(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Analyze price trends using multiple indicators."""
        try:
            close = data['Close'].values
            trends = {}
            
            # Moving Averages
            for period in self.ma_periods:
                ma = talib.SMA(close, timeperiod=period)
                trends[f'MA_{period}'] = {
                    'values': ma,
                    'current': ma[-1],
                    'trend': 'up' if ma[-1] > ma[-2] else 'down'
                }
            
            # ADX (Average Directional Index)
            adx = talib.ADX(data['High'].values, data['Low'].values, close, timeperiod=14)
            
            # Trend strength classification
            trend_strength = 'weak'
            if adx[-1] > 25:
                trend_strength = 'moderate'
            if adx[-1] > 50:
                trend_strength = 'strong'
            
            trends['adx'] = {
                'value': adx[-1],
                'strength': trend_strength
            }
            
            # Overall trend assessment
            price_position = close[-1]
            ma_alignment = all(price_position > ma[-1] for ma in 
                             [trends[f'MA_{period}']['values'] for period in self.ma_periods])
            
            trends['overall'] = {
                'direction': 'bullish' if ma_alignment else 'bearish',
                'strength': trend_strength,
                'price_position': 'above_ma' if ma_alignment else 'below_ma'
            }
            
            return trends
        except Exception as e:
            st.error(f"Error analyzing trends: {str(e)}")
            return {}

    def _analyze_momentum(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Analyze momentum indicators."""
        try:
            close = data['Close'].values
            momentum = {}
            
            # RSI
            rsi = talib.RSI(close, timeperiod=self.rsi_period)
            momentum['rsi'] = {
                'value': rsi[-1],
                'condition': 'overbought' if rsi[-1] > 70 else 'oversold' if rsi[-1] < 30 else 'neutral'
            }
            
            # MACD
            macd, signal, hist = talib.MACD(
                close,
                fastperiod=self.macd_params['fastperiod'],
                slowperiod=self.macd_params['slowperiod'],
                signalperiod=self.macd_params['signalperiod']
            )
            
            momentum['macd'] = {
                'macd': macd[-1],
                'signal': signal[-1],
                'histogram': hist[-1],
                'trend': 'bullish' if hist[-1] > 0 else 'bearish'
            }
            
            # Stochastic
            slowk, slowd = talib.STOCH(
                data['High'].values,
                data['Low'].values,
                close,
                fastk_period=14,
                slowk_period=3,
                slowk_matype=0,
                slowd_period=3,
                slowd_matype=0
            )
            
            momentum['stochastic'] = {
                'k': slowk[-1],
                'd': slowd[-1],
                'condition': 'overbought' if slowk[-1] > 80 else 'oversold' if slowk[-1] < 20 else 'neutral'
            }
            
            return momentum
        except Exception as e:
            st.error(f"Error analyzing momentum: {str(e)}")
            return {}

    def _analyze_volatility(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Analyze volatility indicators."""
        try:
            volatility = {}
            
            # Bollinger Bands
            upper, middle, lower = talib.BBANDS(
                data['Close'].values,
                timeperiod=20,
                nbdevup=2,
                nbdevdn=2,
                matype=0
            )
            
            volatility['bollinger'] = {
                'upper': upper[-1],
                'middle': middle[-1],
                'lower': lower[-1],
                'bandwidth': (upper[-1] - lower[-1]) / middle[-1],
                'position': self._get_bb_position(data['Close'].iloc[-1], upper[-1], lower[-1])
            }
            
            # ATR (Average True Range)
            atr = talib.ATR(
                data['High'].values,
                data['Low'].values,
                data['Close'].values,
                timeperiod=14
            )
            
            volatility['atr'] = {
                'value': atr[-1],
                'percent': (atr[-1] / data['Close'].iloc[-1]) * 100
            }
            
            return volatility
        except Exception as e:
            st.error(f"Error analyzing volatility: {str(e)}")
            return {}

    def _analyze_volume(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Analyze volume patterns and indicators."""
        try:
            volume = {}
            
            # On-Balance Volume (OBV)
            obv = talib.OBV(data['Close'].values, data['Volume'].values)
            
            # Volume Moving Average
            volume_ma = talib.SMA(data['Volume'].values, timeperiod=20)
            
            volume['indicators'] = {
                'obv': obv[-1],
                'obv_trend': 'up' if obv[-1] > obv[-2] else 'down',
                'volume_ma': volume_ma[-1],
                'current_volume': data['Volume'].iloc[-1],
                'volume_trend': 'up' if data['Volume'].iloc[-1] > volume_ma[-1] else 'down'
            }
            
            # Volume Profile
            volume['profile'] = self._calculate_volume_profile(data)
            
            return volume
        except Exception as e:
            st.error(f"Error analyzing volume: {str(e)}")
            return {}

    def _identify_patterns(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Identify chart patterns."""
        try:
            patterns = {}
            high, low, close = data['High'].values, data['Low'].values, data['Close'].values
            
            # Candlestick Patterns
            patterns['candlestick'] = self._identify_candlestick_patterns(high, low, close)
            
            # Chart Patterns
            patterns['chart'] = self._identify_chart_patterns(data)
            
            return patterns
        except Exception as e:
            st.error(f"Error identifying patterns: {str(e)}")
            return {}

    def _find_support_resistance(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Find support and resistance levels."""
        try:
            # Calculate pivot points
            pivot = self._calculate_pivot_points(data)
            
            # Find swing highs and lows
            swings = self._find_swing_points(data)
            
            return {
                'pivot_points': pivot,
                'swing_levels': swings,
                'key_levels': self._identify_key_levels(data, pivot, swings)
            }
        except Exception as e:
            st.error(f"Error finding support/resistance: {str(e)}")
            return {}

    def _generate_signals(self, data: pd.DataFrame) -> Dict[str, str]:
        """Generate trading signals based on technical analysis."""
        try:
            analysis = self.analyze_price_action(data)
            signals = {}
            
            # Trend Signals
            signals['trend'] = self._generate_trend_signals(analysis['trends'])
            
            # Momentum Signals
            signals['momentum'] = self._generate_momentum_signals(analysis['momentum'])
            
            # Volume Signals
            signals['volume'] = self._generate_volume_signals(analysis['volume'])
            
            # Overall Signal
            signals['overall'] = self._combine_signals(signals)
            
            return signals
        except Exception as e:
            st.error(f"Error generating signals: {str(e)}")
            return {}

    def _get_bb_position(self, price: float, upper: float, lower: float) -> str:
        """Determine price position relative to Bollinger Bands."""
        if price > upper:
            return 'above'
        elif price < lower:
            return 'below'
        return 'inside'

    def _calculate_volume_profile(self, data: pd.DataFrame) -> Dict[str, float]:
        """Calculate volume profile metrics."""
        try:
            price_buckets = pd.qcut(data['Close'], q=10)
            volume_profile = data.groupby(price_buckets)['Volume'].sum()
            
            return {
                'poc_price': volume_profile.idxmax().mid,  # Point of Control
                'volume_by_price': volume_profile.to_dict(),
                'high_volume_range': [
                    volume_profile.nlargest(3).index[0].left,
                    volume_profile.nlargest(3).index[0].right
                ]
            }
        except Exception as e:
            st.error(f"Error calculating volume profile: {str(e)}")
            return {}

    def _identify_candlestick_patterns(self, high: np.ndarray, low: np.ndarray, 
                                     close: np.ndarray) -> List[str]:
        """Identify candlestick patterns."""
        patterns = []
        
        # Define pattern recognition functions
        pattern_functions = {
            'Doji': talib.CDLDOJI,
            'Hammer': talib.CDLHAMMER,
            'Engulfing': talib.CDLENGULFING,
            'Morning Star': talib.CDLMORNINGSTAR,
            'Evening Star': talib.CDLEVENINGSTAR
        }
        
        for pattern_name, pattern_func in pattern_functions.items():
            try:
                result = pattern_func(high, low, close)
                if result[-1] != 0:
                    patterns.append(pattern_name)
            except:
                continue
                
        return patterns

    def _combine_signals(self, signals: Dict[str, str]) -> str:
        """Combine different signals into overall signal."""
        # Weight different signals
        weights = {
            'trend': 0.4,
            'momentum': 0.3,
            'volume': 0.3
        }
        
        # Convert signals to numerical scores
        scores = {
            'bullish': 1,
            'neutral': 0,
            'bearish': -1
        }
        
        total_score = 0
        for signal_type, weight in weights.items():
            if signal_type in signals:
                score = scores.get(signals[signal_type], 0)
                total_score += score * weight
        
        # Convert back to signal
        if total_score > 0.2:
            return 'bullish'
        elif total_score < -0.2:
            return 'bearish'
        return 'neutral'

================
File: src/models/__init__.py
================
from .database import (
    Base,
    StockData,
    FinancialStatement,
    Analysis,
    NewsArticle,
    DatabaseManager
)

__all__ = [
    'Base',
    'StockData',
    'FinancialStatement',
    'Analysis',
    'NewsArticle',
    'DatabaseManager'
]

================
File: src/models/database.py
================
from datetime import datetime
from typing import Dict, Any, Optional
from sqlalchemy import create_engine, Column, Integer, Float, String, DateTime, JSON, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, sessionmaker
import streamlit as st

Base = declarative_base()

class StockData(Base):
    """Stock price and volume data."""
    __tablename__ = 'stock_data'
    
    id = Column(Integer, primary_key=True)
    ticker = Column(String, index=True)
    timestamp = Column(DateTime, index=True)
    open = Column(Float)
    high = Column(Float)
    low = Column(Float)
    close = Column(Float)
    volume = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'ticker': self.ticker,
            'timestamp': self.timestamp,
            'open': self.open,
            'high': self.high,
            'low': self.low,
            'close': self.close,
            'volume': self.volume
        }

class FinancialStatement(Base):
    """Financial statement data."""
    __tablename__ = 'financial_statements'
    
    id = Column(Integer, primary_key=True)
    ticker = Column(String, index=True)
    statement_type = Column(String)  # income_statement, balance_sheet, cash_flow
    period_end = Column(DateTime, index=True)
    data = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

class Analysis(Base):
    """Analysis results."""
    __tablename__ = 'analysis'
    
    id = Column(Integer, primary_key=True)
    ticker = Column(String, index=True)
    analysis_type = Column(String)  # technical, fundamental, risk, sentiment
    timestamp = Column(DateTime, index=True)
    data = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)

class NewsArticle(Base):
    """News article data."""
    __tablename__ = 'news_articles'
    
    id = Column(Integer, primary_key=True)
    ticker = Column(String, index=True)
    title = Column(String)
    content = Column(String)
    source = Column(String)
    url = Column(String)
    published_at = Column(DateTime, index=True)
    sentiment_score = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)

class DatabaseManager:
    """Manager class for database operations."""
    
    def __init__(self):
        self.engine = create_engine(st.secrets["DATABASE_URL"])
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)

    def save_stock_data(self, data: Dict[str, Any]):
        """Save stock data to database."""
        session = self.Session()
        try:
            stock_data = StockData(**data)
            session.add(stock_data)
            session.commit()
        except Exception as e:
            session.rollback()
            raise e
        finally:
            session.close()

    def save_financial_statement(self, data: Dict[str, Any]):
        """Save financial statement to database."""
        session = self.Session()
        try:
            statement = FinancialStatement(**data)
            session.add(statement)
            session.commit()
        except Exception as e:
            session.rollback()
            raise e
        finally:
            session.close()

    def save_analysis(self, data: Dict[str, Any]):
        """Save analysis results to database."""
        session = self.Session()
        try:
            analysis = Analysis(**data)
            session.add(analysis)
            session.commit()
        except Exception as e:
            session.rollback()
            raise e
        finally:
            session.close()

    def save_news_article(self, data: Dict[str, Any]):
        """Save news article to database."""
        session = self.Session()
        try:
            article = NewsArticle(**data)
            session.add(article)
            session.commit()
        except Exception as e:
            session.rollback()
            raise e
        finally:
            session.close()

    def get_latest_stock_data(self, ticker: str) -> Optional[Dict[str, Any]]:
        """Get latest stock data for ticker."""
        session = self.Session()
        try:
            data = session.query(StockData)\
                .filter(StockData.ticker == ticker)\
                .order_by(StockData.timestamp.desc())\
                .first()
            return data.to_dict() if data else None
        finally:
            session.close()

    def get_analysis_history(self, ticker: str, 
                           analysis_type: str) -> List[Dict[str, Any]]:
        """Get analysis history for ticker."""
        session = self.Session()
        try:
            analyses = session.query(Analysis)\
                .filter(Analysis.ticker == ticker,
                       Analysis.analysis_type == analysis_type)\
                .order_by(Analysis.timestamp.desc())\
                .all()
            return [{'timestamp': a.timestamp, 'data': a.data} for a in analyses]
        finally:
            session.close()

================
File: src/pages/00_ðŸ _Home.py
================
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
from ..data import MarketDataLoader
from ..analysis import AnalysisManager
from ..utils import FormatHelper, TimeHelper

# Page configuration
st.set_page_config(
    page_title="Investment Analysis - Home",
    page_icon="ðŸ ",
    layout="wide"
)

class HomePage:
    def __init__(self):
        self.market_data = MarketDataLoader()
        self.analysis = AnalysisManager()
        self.format = FormatHelper()
        
    def run(self):
        # Sidebar
        with st.sidebar:
            self.render_sidebar()
        
        # Main content
        st.title("Investment Analysis Dashboard")
        
        # Get ticker from session state or default
        ticker = st.session_state.get('ticker', 'AAPL')
        
        # Market Overview
        self.render_market_overview(ticker)
        
        # Analysis Summary
        self.render_analysis_summary(ticker)
        
        # Recent News
        self.render_recent_news(ticker)
    
    def render_sidebar(self):
        st.title("Settings")
        
        # Ticker input
        ticker = st.text_input(
            "Enter Ticker",
            value=st.session_state.get('ticker', 'AAPL')
        ).upper()
        
        if ticker != st.session_state.get('ticker'):
            st.session_state.ticker = ticker
            st.experimental_rerun()
        
        # Time period selector
        st.selectbox(
            "Time Period",
            options=['1D', '1W', '1M', '3M', '1Y', '5Y'],
            key='timeperiod'
        )
        
        # Analysis options
        st.divider()
        st.markdown("### Analysis Options")
        
        st.checkbox("Technical Analysis", value=True, key='show_technical')
        st.checkbox("Fundamental Analysis", value=True, key='show_fundamental')
        st.checkbox("Risk Metrics", value=True, key='show_risk')
        st.checkbox("Sentiment Analysis", value=True, key='show_sentiment')
    
    def render_market_overview(self, ticker):
        st.header("Market Overview")
        
        try:
            # Get market data
            data = self.market_data.get_market_data(ticker, '1d')
            
            # Create columns for metrics
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                self.metric_card(
                    "Current Price",
                    self.format.format_currency(data['Close'].iloc[-1]),
                    f"{data['Close'].pct_change().iloc[-1]:.2%}"
                )
                
            with col2:
                self.metric_card(
                    "Volume",
                    self.format.format_large_number(data['Volume'].iloc[-1]),
                    f"{data['Volume'].pct_change().iloc[-1]:.2%}"
                )
                
            with col3:
                self.metric_card(
                    "Day Range",
                    f"{self.format.format_currency(data['Low'].iloc[-1])} - "
                    f"{self.format.format_currency(data['High'].iloc[-1])}"
                )
                
            with col4:
                market_status = "Open" if TimeHelper.is_market_open() else "Closed"
                self.metric_card("Market Status", market_status)
            
            # Price chart
            st.plotly_chart(
                self.market_data.create_price_chart(data),
                use_container_width=True
            )
            
        except Exception as e:
            st.error(f"Error loading market data: {str(e)}")
    
    def render_analysis_summary(self, ticker):
        st.header("Analysis Summary")
        
        try:
            # Get analysis results
            analysis = self.analysis.perform_complete_analysis(
                ticker,
                self.market_data.get_market_data(ticker, '1y'),
                [],  # news data
                {}   # financial reports
            )
            
            # Create columns for different analyses
            col1, col2, col3 = st.columns(3)
            
            with col1:
                if st.session_state.show_technical:
                    st.subheader("Technical Analysis")
                    signals = analysis['technical']['signals']
                    for signal, value in signals.items():
                        st.info(f"{signal}: {value}")
            
            with col2:
                if st.session_state.show_fundamental:
                    st.subheader("Fundamental Analysis")
                    metrics = analysis['fundamental']['profitability']
                    for metric, value in metrics.items():
                        st.metric(metric, f"{value:.2%}")
            
            with col3:
                if st.session_state.show_risk:
                    st.subheader("Risk Metrics")
                    risk = analysis['risk']
                    for metric, value in risk.items():
                        if isinstance(value, dict):
                            continue
                        st.metric(metric, f"{value:.2f}")
            
        except Exception as e:
            st.error(f"Error loading analysis: {str(e)}")
    
    def render_recent_news(self, ticker):
        st.header("Recent News")
        
        try:
            news = self.market_data.get_company_news(ticker)
            
            for article in news[:5]:  # Show 5 most recent articles
                with st.expander(article['title']):
                    st.write(article['description'])
                    st.caption(
                        f"Source: {article['source']} | "
                        f"Published: {article['published_at']}"
                    )
                    if article.get('sentiment'):
                        sentiment = article['sentiment']
                        st.progress(
                            (sentiment + 1) / 2,  # Convert -1 to 1 to 0 to 1
                            text=f"Sentiment: {sentiment:.2f}"
                        )
        
        except Exception as e:
            st.error(f"Error loading news: {str(e)}")
    
    @staticmethod
    def metric_card(label, value, delta=None):
        if delta:
            st.metric(label, value, delta)
        else:
            st.metric(label, value)

if __name__ == "__main__":
    home_page = HomePage()
    home_page.run()

================
File: src/pages/01_ðŸ“ˆ_Technical.py
================
import streamlit as st
import pandas as pd
from src.data import MarketDataLoader
from src.analysis import TechnicalAnalyzer
from src.utils import VisualizationHelper
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Page configuration
st.set_page_config(
    page_title="Technical Analysis",
    page_icon="ðŸ“ˆ",
    layout="wide"
)

class TechnicalPage:
    def __init__(self):
        self.market_data = MarketDataLoader()
        self.analyzer = TechnicalAnalyzer()
        self.viz = VisualizationHelper()
        
    def run(self):
        st.title("Technical Analysis")
        
        # Sidebar controls
        with st.sidebar:
            self.render_sidebar()
        
        # Get data
        ticker = st.session_state.get('ticker', 'AAPL')
        period = st.session_state.get('timeperiod', '1y')
        data = self.market_data.get_market_data(ticker, period)
        
        # Main chart
        self.render_main_chart(data)
        
        # Technical indicators
        self.render_technical_indicators(data)
        
        # Pattern analysis
        self.render_pattern_analysis(data)
        
        # Support/Resistance levels
        self.render_support_resistance(data)
    
    def render_sidebar(self):
        st.title("Analysis Settings")
        
        # Indicator selection
        st.subheader("Select Indicators")
        
        # Moving Averages
        st.markdown("#### Moving Averages")
        st.checkbox("SMA 20", value=True, key='sma_20')
        st.checkbox("SMA 50", value=True, key='sma_50')
        st.checkbox("SMA 200", value=True, key='sma_200')
        st.checkbox("EMA 20", value=False, key='ema_20')
        
        # Oscillators
        st.markdown("#### Oscillators")
        st.checkbox("RSI", value=True, key='show_rsi')
        st.checkbox("MACD", value=True, key='show_macd')
        st.checkbox("Stochastic", value=False, key='show_stoch')
        
        # Volume Analysis
        st.markdown("#### Volume")
        st.checkbox("Volume", value=True, key='show_volume')
        st.checkbox("OBV", value=False, key='show_obv')
        
        # Pattern Recognition
        st.markdown("#### Patterns")
        st.checkbox("Candlestick Patterns", value=True, key='show_patterns')
        st.checkbox("Support/Resistance", value=True, key='show_sr')
    
    def render_main_chart(self, data):
        st.header("Price Chart")
        
        # Create figure with secondary y-axis
        fig = make_subplots(
            rows=2, cols=1,
            shared_xaxes=True,
            vertical_spacing=0.03,
            row_heights=[0.7, 0.3]
        )
        
        # Add candlestick
        fig.add_trace(
            go.Candlestick(
                x=data.index,
                open=data['Open'],
                high=data['High'],
                low=data['Low'],
                close=data['Close'],
                name='OHLC'
            ),
            row=1, col=1
        )
        
        # Add Moving Averages
        if st.session_state.sma_20:
            fig.add_trace(
                go.Scatter(
                    x=data.index,
                    y=data['Close'].rolling(20).mean(),
                    name='SMA 20',
                    line=dict(color='blue', width=1)
                ),
                row=1, col=1
            )
        
        if st.session_state.sma_50:
            fig.add_trace(
                go.Scatter(
                    x=data.index,
                    y=data['Close'].rolling(50).mean(),
                    name='SMA 50',
                    line=dict(color='orange', width=1)
                ),
                row=1, col=1
            )
        
        # Add volume bars
        if st.session_state.show_volume:
            colors = ['red' if row['Open'] > row['Close'] else 'green' 
                     for idx, row in data.iterrows()]
            fig.add_trace(
                go.Bar(
                    x=data.index,
                    y=data['Volume'],
                    name='Volume',
                    marker_color=colors
                ),
                row=2, col=1
            )
        
        # Update layout
        fig.update_layout(
            height=800,
            xaxis_rangeslider_visible=False,
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    def render_technical_indicators(self, data):
        st.header("Technical Indicators")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.session_state.show_rsi:
                self.render_rsi_chart(data)
            
            if st.session_state.show_stoch:
                self.render_stochastic_chart(data)
        
        with col2:
            if st.session_state.show_macd:
                self.render_macd_chart(data)
            
            if st.session_state.show_obv:
                self.render_obv_chart(data)
    
    def render_pattern_analysis(self, data):
        if st.session_state.show_patterns:
            st.header("Pattern Analysis")
            
            # Get pattern analysis
            patterns = self.analyzer._identify_patterns(
                data['High'].values,
                data['Low'].values,
                data['Close'].values
            )
            
            if patterns:
                for pattern in patterns:
                    st.info(f"Detected Pattern: {pattern}")
            else:
                st.write("No significant patterns detected in the current timeframe.")
    
    def render_support_resistance(self, data):
        if st.session_state.show_sr:
            st.header("Support & Resistance Levels")
            
            # Get S/R levels
            levels = self.analyzer._find_support_resistance(data)
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.subheader("Support Levels")
                for level in levels['support']:
                    st.write(f"${level:.2f}")
            
            with col2:
                st.subheader("Resistance Levels")
                for level in levels['resistance']:
                    st.write(f"${level:.2f}")
    
    def render_rsi_chart(self, data):
        """Render RSI chart."""
        fig = go.Figure()
        
        rsi = self.analyzer._calculate_rsi(data['Close'])
        
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=rsi,
                name='RSI'
            )
        )
        
        # Add overbought/oversold lines
        fig.add_hline(y=70, line_dash="dash", line_color="red")
        fig.add_hline(y=30, line_dash="dash", line_color="green")
        
        fig.update_layout(
            title="Relative Strength Index (RSI)",
            height=300,
            yaxis_title="RSI",
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    def render_macd_chart(self, data):
        """Render MACD chart."""
        fig = go.Figure()
        
        macd = self.analyzer._calculate_macd(data['Close'])
        
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=macd['macd'],
                name='MACD'
            )
        )
        
        fig.add_trace(
            go.Scatter(
                x=data.index,
                y=macd['signal'],
                name='Signal'
            )
        )
        
        fig.add_trace(
            go.Bar(
                x=data.index,
                y=macd['hist'],
                name='Histogram'
            )
        )
        
        fig.update_layout(
            title="MACD",
            height=300,
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)

if __name__ == "__main__":
    technical_page = TechnicalPage()
    technical_page.run()

================
File: src/pages/02_ðŸ“Š_Fundamental.py
================
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from src.data import FinancialDataLoader
from src.analysis import FundamentalAnalyzer
from src.utils import FormatHelper

# Page configuration
st.set_page_config(
    page_title="Fundamental Analysis",
    page_icon="ðŸ“Š",
    layout="wide"
)

class FundamentalPage:
    def __init__(self):
        self.financial_data = FinancialDataLoader()
        self.analyzer = FundamentalAnalyzer()
        self.format = FormatHelper()
        
    def run(self):
        st.title("Fundamental Analysis")
        
        # Sidebar controls
        with st.sidebar:
            self.render_sidebar()
        
        # Get data
        ticker = st.session_state.get('ticker', 'AAPL')
        
        try:
            # Get financial data and analysis
            financials = self.financial_data.get_financial_statements(ticker)
            analysis = self.analyzer.analyze_company(ticker)
            
            # Render different sections
            self.render_company_overview(financials['info'])
            self.render_key_metrics(analysis)
            self.render_financial_statements(financials)
            self.render_ratio_analysis(analysis)
            self.render_growth_analysis(analysis)
            self.render_valuation_analysis(analysis)
            
        except Exception as e:
            st.error(f"Error loading fundamental data: {str(e)}")
    
    def render_sidebar(self):
        st.title("Analysis Settings")
        
        # Statement selection
        st.subheader("Financial Statements")
        st.checkbox("Income Statement", value=True, key='show_income')
        st.checkbox("Balance Sheet", value=True, key='show_balance')
        st.checkbox("Cash Flow", value=True, key='show_cashflow')
        
        # Ratio selection
        st.subheader("Ratio Analysis")
        st.checkbox("Profitability", value=True, key='show_profitability')
        st.checkbox("Liquidity", value=True, key='show_liquidity')
        st.checkbox("Solvency", value=True, key='show_solvency')
        st.checkbox("Efficiency", value=True, key='show_efficiency')
        
        # Comparison settings
        st.subheader("Comparison")
        st.multiselect(
            "Compare with",
            options=['Industry Average', 'Sector Average', 'S&P 500'],
            default=['Industry Average'],
            key='comparisons'
        )
    
    def render_company_overview(self, info):
        st.header("Company Overview")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric(
                "Market Cap",
                self.format.format_currency(info.get('marketCap', 0))
            )
            st.metric(
                "Sector",
                info.get('sector', 'N/A')
            )
        
        with col2:
            st.metric(
                "P/E Ratio",
                f"{info.get('trailingPE', 0):.2f}"
            )
            st.metric(
                "Industry",
                info.get('industry', 'N/A')
            )
        
        with col3:
            st.metric(
                "Dividend Yield",
                f"{info.get('dividendYield', 0)*100:.2f}%"
            )
            st.metric(
                "Beta",
                f"{info.get('beta', 0):.2f}"
            )
        
        # Company description
        with st.expander("Business Description"):
            st.write(info.get('longBusinessSummary', 'No description available.'))
    
    def render_key_metrics(self, analysis):
        st.header("Key Metrics")
        
        metrics = analysis['profitability']
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "ROE",
                f"{metrics.get('roe', 0)*100:.2f}%"
            )
        
        with col2:
            st.metric(
                "ROA",
                f"{metrics.get('roa', 0)*100:.2f}%"
            )
        
        with col3:
            st.metric(
                "Net Margin",
                f"{metrics.get('net_margin', 0)*100:.2f}%"
            )
        
        with col4:
            st.metric(
                "Operating Margin",
                f"{metrics.get('operating_margin', 0)*100:.2f}%"
            )
    
    def render_financial_statements(self, financials):
        st.header("Financial Statements")
        
        tabs = st.tabs(["Income Statement", "Balance Sheet", "Cash Flow"])
        
        with tabs[0]:
            if st.session_state.show_income:
                self.render_income_statement(financials['income_statement'])
        
        with tabs[1]:
            if st.session_state.show_balance:
                self.render_balance_sheet(financials['balance_sheet'])
        
        with tabs[2]:
            if st.session_state.show_cashflow:
                self.render_cash_flow(financials['cash_flow'])
    
    def render_ratio_analysis(self, analysis):
        st.header("Ratio Analysis")
        
        tabs = st.tabs(["Profitability", "Liquidity", "Solvency", "Efficiency"])
        
        with tabs[0]:
            if st.session_state.show_profitability:
                self.render_profitability_ratios(analysis['profitability'])
        
        with tabs[1]:
            if st.session_state.show_liquidity:
                self.render_liquidity_ratios(analysis['liquidity'])
        
        with tabs[2]:
            if st.session_state.show_solvency:
                self.render_solvency_ratios(analysis['solvency'])
        
        with tabs[3]:
            if st.session_state.show_efficiency:
                self.render_efficiency_ratios(analysis['efficiency'])
    
    def render_growth_analysis(self, analysis):
        st.header("Growth Analysis")
        
        growth = analysis['growth']
        
        # Create growth chart
        fig = go.Figure()
        
        metrics = ['revenue_growth', 'net_income_growth', 'eps_growth']
        for metric in metrics:
            fig.add_trace(
                go.Bar(
                    name=metric.replace('_', ' ').title(),
                    x=['YoY Growth'],
                    y=[growth.get(metric, 0)*100]
                )
            )
        
        fig.update_layout(
            title="Year-over-Year Growth Rates",
            yaxis_title="Growth Rate (%)",
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    def render_valuation_analysis(self, analysis):
        st.header("Valuation Analysis")
        
        valuation = analysis['valuation']
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Valuation metrics
            metrics = {
                'P/E Ratio': valuation.get('pe_ratio', 0),
                'P/B Ratio': valuation.get('price_to_book', 0),
                'EV/EBITDA': valuation.get('ev_to_ebitda', 0)
            }
            
            for name, value in metrics.items():
                st.metric(name, f"{value:.2f}")
        
        with col2:
            # Valuation comparison chart
            if 'Industry Average' in st.session_state.comparisons:
                self.render_valuation_comparison(valuation)
    
    def render_income_statement(self, data):
        """Render income statement with visualization."""
        # Format data
        df = pd.DataFrame(data)
        df = df.round(2)
        
        # Show table
        st.dataframe(df)
        
        # Create visualization
        fig = go.Figure()
        
        # Revenue and Net Income trends
        fig.add_trace(
            go.Scatter(
                x=df.index,
                y=df['Total Revenue'],
                name='Revenue'
            )
        )
        
        fig.add_trace(
            go.Scatter(
                x=df.index,
                y=df['Net Income'],
                name='Net Income'
            )
        )
        
        fig.update_layout(
            title="Revenue and Net Income Trends",
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    def render_profitability_ratios(self, ratios):
        """Render profitability ratios with comparison."""
        fig = go.Figure()
        
        metrics = {
            'Gross Margin': ratios.get('gross_margin', 0),
            'Operating Margin': ratios.get('operating_margin', 0),
            'Net Margin': ratios.get('net_margin', 0),
            'ROE': ratios.get('roe', 0),
            'ROA': ratios.get('roa', 0)
        }
        
        fig.add_trace(
            go.Bar(
                x=list(metrics.keys()),
                y=[v*100 for v in metrics.values()],
                name='Company'
            )
        )
        
        if 'Industry Average' in st.session_state.comparisons:
            # Add industry average comparison
            pass
        
        fig.update_layout(
            title="Profitability Ratios",
            yaxis_title="Percentage (%)",
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)

if __name__ == "__main__":
    fundamental_page = FundamentalPage()
    fundamental_page.run()

================
File: src/pages/03_âš ï¸_Risk.py
================
import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from src.data import MarketDataLoader
from src.analysis import RiskAnalyzer
from src.utils import FormatHelper

# Page configuration
st.set_page_config(
    page_title="Risk Analysis",
    page_icon="âš ï¸",
    layout="wide"
)

class RiskPage:
    def __init__(self):
        self.market_data = MarketDataLoader()
        self.analyzer = RiskAnalyzer()
        self.format = FormatHelper()
        
    def run(self):
        st.title("Risk Analysis")
        
        # Sidebar controls
        with st.sidebar:
            self.render_sidebar()
        
        # Get data
        ticker = st.session_state.get('ticker', 'AAPL')
        period = st.session_state.get('timeperiod', '1y')
        
        try:
            # Get market data
            data = self.market_data.get_market_data(ticker, period)
            
            # Calculate risk metrics
            risk_metrics = self.analyzer.calculate_risk_metrics(data)
            
            # Render different sections
            self.render_risk_overview(risk_metrics)
            self.render_volatility_analysis(data, risk_metrics)
            self.render_var_analysis(risk_metrics)
            self.render_correlation_analysis(data)
            self.render_risk_alerts(risk_metrics)
            
        except Exception as e:
            st.error(f"Error analyzing risk metrics: {str(e)}")
    
    def render_sidebar(self):
        st.title("Risk Settings")
        
        # VaR settings
        st.subheader("Value at Risk")
        st.slider(
            "Confidence Level",
            min_value=0.90,
            max_value=0.99,
            value=0.95,
            step=0.01,
            key='var_confidence'
        )
        
        # Volatility settings
        st.subheader("Volatility")
        st.selectbox(
            "Calculation Method",
            options=['Historical', 'EWMA', 'GARCH'],
            key='vol_method'
        )
        
        # Correlation settings
        st.subheader("Correlation Analysis")
        st.multiselect(
            "Compare with",
            options=['SPY', 'QQQ', 'IWM', 'VIX'],
            default=['SPY'],
            key='correlation_assets'
        )
        
        # Risk alert settings
        st.subheader("Risk Alerts")
        st.number_input(
            "Volatility Alert Threshold",
            min_value=0.0,
            max_value=1.0,
            value=0.3,
            step=0.05,
            key='vol_threshold'
        )
    
    def render_risk_overview(self, risk_metrics):
        st.header("Risk Overview")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            vol = risk_metrics['volatility']
            st.metric(
                "Annual Volatility",
                f"{vol['annual_volatility']*100:.2f}%",
                delta=f"{(vol['current_rolling_vol']-vol['annual_volatility'])*100:.2f}%"
            )
        
        with col2:
            var = risk_metrics['value_at_risk']
            st.metric(
                "Value at Risk (95%)",
                f"{abs(var['historical_var'])*100:.2f}%"
            )
        
        with col3:
            beta = risk_metrics['beta']
            st.metric(
                "Beta",
                f"{beta['beta']:.2f}",
                delta=f"RÂ²: {beta['r_squared']:.2f}"
            )
        
        with col4:
            drawdown = risk_metrics['drawdown']
            st.metric(
                "Maximum Drawdown",
                f"{abs(drawdown['max_drawdown'])*100:.2f}%"
            )
    
    def render_volatility_analysis(self, data, risk_metrics):
        st.header("Volatility Analysis")
        
        # Create returns series
        returns = data['Close'].pct_change().dropna()
        
        # Create figure with two subplots
        fig = make_subplots(
            rows=2, cols=1,
            subplot_titles=("Returns Distribution", "Rolling Volatility"),
            vertical_spacing=0.15
        )
        
        # Returns distribution
        fig.add_trace(
            go.Histogram(
                x=returns,
                name="Returns",
                nbinsx=50,
                showlegend=False
            ),
            row=1, col=1
        )
        
        # Rolling volatility
        rolling_vol = returns.rolling(window=30).std() * np.sqrt(252)
        fig.add_trace(
            go.Scatter(
                x=rolling_vol.index,
                y=rolling_vol,
                name="30-Day Volatility"
            ),
            row=2, col=1
        )
        
        fig.update_layout(height=600, template='plotly_white')
        st.plotly_chart(fig, use_container_width=True)
        
        # Additional volatility metrics
        with st.expander("Detailed Volatility Metrics"):
            col1, col2 = st.columns(2)
            
            with col1:
                st.write("Historical Volatility Metrics:")
                volatility = risk_metrics['volatility']
                for metric, value in volatility.items():
                    if isinstance(value, (int, float)):
                        st.write(f"{metric}: {value*100:.2f}%")
            
            with col2:
                st.write("Forward Volatility Estimate:")
                st.write(f"{volatility.get('forward_vol_estimate', 0)*100:.2f}%")
    
    def render_var_analysis(self, risk_metrics):
        st.header("Value at Risk (VaR) Analysis")
        
        var = risk_metrics['value_at_risk']
        
        col1, col2 = st.columns(2)
        
        with col1:
            # VaR metrics
            st.subheader("VaR Metrics")
            st.metric(
                "Historical VaR",
                f"{abs(var['historical_var'])*100:.2f}%"
            )
            st.metric(
                "Parametric VaR",
                f"{abs(var['parametric_var'])*100:.2f}%"
            )
            st.metric(
                "Conditional VaR",
                f"{abs(var['conditional_var'])*100:.2f}%"
            )
        
        with col2:
            # VaR visualization
            fig = go.Figure()
            
            methods = ['Historical', 'Parametric', 'Conditional']
            values = [
                var['historical_var'],
                var['parametric_var'],
                var['conditional_var']
            ]
            
            fig.add_trace(
                go.Bar(
                    x=methods,
                    y=[abs(v)*100 for v in values],
                    name='VaR'
                )
            )
            
            fig.update_layout(
                title="VaR Comparison",
                yaxis_title="VaR (%)",
                template='plotly_white'
            )
            
            st.plotly_chart(fig, use_container_width=True)
    
    def render_correlation_analysis(self, data):
        st.header("Correlation Analysis")
        
        # Get correlation assets
        correlation_assets = st.session_state.correlation_assets
        
        if correlation_assets:
            # Calculate correlations
            correlations = self.analyzer.calculate_correlations(
                data,
                correlation_assets
            )
            
            # Create heatmap
            fig = go.Figure(
                data=go.Heatmap(
                    z=correlations.values,
                    x=correlations.columns,
                    y=correlations.index,
                    colorscale='RdBu',
                    zmin=-1,
                    zmax=1
                )
            )
            
            fig.update_layout(
                title="Correlation Matrix",
                template='plotly_white'
            )
            
            st.plotly_chart(fig, use_container_width=True)
    
    def render_risk_alerts(self, risk_metrics):
        st.header("Risk Alerts")
        
        # Check volatility threshold
        vol_threshold = st.session_state.vol_threshold
        current_vol = risk_metrics['volatility']['current_rolling_vol']
        
        if current_vol > vol_threshold:
            st.warning(
                f"âš ï¸ Current volatility ({current_vol*100:.2f}%) is above "
                f"threshold ({vol_threshold*100:.2f}%)"
            )
        
        # Check VaR threshold
        var = risk_metrics['value_at_risk']['historical_var']
        if abs(var) > 0.05:  # 5% VaR threshold
            st.warning(
                f"âš ï¸ Value at Risk ({abs(var)*100:.2f}%) indicates "
                "significant potential losses"
            )
        
        # Check correlation risks
        beta = risk_metrics['beta']['beta']
        if beta > 1.5:
            st.warning(
                f"âš ï¸ High market sensitivity (Beta: {beta:.2f}) indicates "
                "increased market risk"
            )
        
        # Check drawdown
        max_drawdown = risk_metrics['drawdown']['max_drawdown']
        if abs(max_drawdown) > 0.2:  # 20% drawdown threshold
            st.warning(
                f"âš ï¸ Large maximum drawdown ({abs(max_drawdown)*100:.2f}%) "
                "indicates significant downside risk"
            )

if __name__ == "__main__":
    risk_page = RiskPage()
    risk_page.run()

================
File: src/pages/04_ðŸ“°_News.py
================
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from datetime import datetime, timedelta
from src.data import NewsDataLoader
from src.analysis import SentimentAnalyzer
from src.utils import TimeHelper

# Page configuration
st.set_page_config(
    page_title="News & Sentiment",
    page_icon="ðŸ“°",
    layout="wide"
)

class NewsPage:
    def __init__(self):
        self.news_loader = NewsDataLoader()
        self.sentiment_analyzer = SentimentAnalyzer()
        self.time_helper = TimeHelper()
        
    def run(self):
        st.title("News & Sentiment Analysis")
        
        # Sidebar controls
        with st.sidebar:
            self.render_sidebar()
        
        # Get data
        ticker = st.session_state.get('ticker', 'AAPL')
        days = st.session_state.get('news_days', 30)
        
        try:
            # Get news and sentiment data
            news_data = self.news_loader.get_company_news(ticker, days)
            sentiment_analysis = self.sentiment_analyzer.analyze_sentiment(
                ticker, news_data, {}
            )
            
            # Render different sections
            self.render_sentiment_overview(sentiment_analysis)
            self.render_sentiment_trends(sentiment_analysis)
            self.render_news_feed(news_data)
            self.render_topic_analysis(sentiment_analysis)
            self.render_social_media_sentiment(sentiment_analysis)
            
        except Exception as e:
            st.error(f"Error loading news and sentiment data: {str(e)}")
    
    def render_sidebar(self):
        st.title("News Settings")
        
        # Time range
        st.subheader("Time Range")
        st.slider(
            "Days to analyze",
            min_value=7,
            max_value=90,
            value=30,
            step=1,
            key='news_days'
        )
        
        # News sources
        st.subheader("News Sources")
        st.multiselect(
            "Select Sources",
            options=['All', 'Financial News', 'Press Releases', 'SEC Filings'],
            default=['All'],
            key='news_sources'
        )
        
        # Sentiment filters
        st.subheader("Sentiment Filter")
        st.select_slider(
            "Sentiment Range",
            options=['Very Negative', 'Negative', 'Neutral', 'Positive', 'Very Positive'],
            value=('Very Negative', 'Very Positive'),
            key='sentiment_range'
        )
        
        # Topic filters
        st.subheader("Topic Filter")
        st.multiselect(
            "Select Topics",
            options=['Earnings', 'Products', 'Management', 'Markets', 'Competition'],
            key='topics'
        )
    
    def render_sentiment_overview(self, sentiment_analysis):
        st.header("Sentiment Overview")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            overall_score = sentiment_analysis['overall_sentiment']
            st.metric(
                "Overall Sentiment",
                f"{overall_score:.2f}",
                delta=self._get_sentiment_trend(sentiment_analysis)
            )
        
        with col2:
            sentiment_dist = sentiment_analysis['news_sentiment']['sentiment_distribution']
            total_articles = sum(sentiment_dist.values())
            positive_ratio = sentiment_dist['positive'] / total_articles
            st.metric(
                "Positive News Ratio",
                f"{positive_ratio:.1%}"
            )
        
        with col3:
            source_analysis = sentiment_analysis['news_sentiment']['source_analysis']
            avg_reliability = np.mean([s.get('reliability', 0) for s in source_analysis.values()])
            st.metric(
                "Source Reliability",
                f"{avg_reliability:.1%}"
            )
        
        # Sentiment gauge chart
        fig = go.Figure(go.Indicator(
            mode = "gauge+number",
            value = (overall_score + 1) * 50,  # Convert -1 to 1 to 0 to 100
            gauge = {
                'axis': {'range': [0, 100]},
                'steps': [
                    {'range': [0, 33], 'color': "lightgray"},
                    {'range': [33, 66], 'color': "gray"},
                    {'range': [66, 100], 'color': "darkgray"}
                ],
                'bar': {'color': self._get_sentiment_color(overall_score)}
            }
        ))
        
        fig.update_layout(height=200)
        st.plotly_chart(fig, use_container_width=True)
    
    def render_sentiment_trends(self, sentiment_analysis):
        st.header("Sentiment Trends")
        
        # Get sentiment trends data
        trends = sentiment_analysis['sentiment_trends']
        
        # Create line chart
        fig = go.Figure()
        
        fig.add_trace(
            go.Scatter(
                x=trends['dates'],
                y=trends['sentiment_scores'],
                name='Daily Sentiment',
                line=dict(color='blue')
            )
        )
        
        # Add moving average
        fig.add_trace(
            go.Scatter(
                x=trends['dates'],
                y=pd.Series(trends['sentiment_scores']).rolling(7).mean(),
                name='7-Day Moving Average',
                line=dict(color='red', dash='dash')
            )
        )
        
        fig.update_layout(
            title="Sentiment Score Trends",
            xaxis_title="Date",
            yaxis_title="Sentiment Score",
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    def render_news_feed(self, news_data):
        st.header("News Feed")
        
        # Filter news based on sentiment range
        sentiment_range = st.session_state.sentiment_range
        filtered_news = self._filter_news_by_sentiment(news_data, sentiment_range)
        
        # Create tabs for different news categories
        tabs = st.tabs(["All News", "High Impact", "Press Releases", "SEC Filings"])
        
        with tabs[0]:
            self._render_news_list(filtered_news)
        
        with tabs[1]:
            high_impact = [n for n in filtered_news if n.get('impact_score', 0) > 0.7]
            self._render_news_list(high_impact)
        
        with tabs[2]:
            press_releases = [n for n in filtered_news if n['source'] == 'Press Release']
            self._render_news_list(press_releases)
        
        with tabs[3]:
            sec_filings = [n for n in filtered_news if n['source'] == 'SEC']
            self._render_news_list(sec_filings)
    
    def render_topic_analysis(self, sentiment_analysis):
        st.header("Topic Analysis")
        
        topics = sentiment_analysis.get('key_topics', [])
        
        # Create treemap of topics
        fig = go.Figure(go.Treemap(
            labels=[topic['topic'] for topic in topics],
            parents=[''] * len(topics),
            values=[topic['frequency'] for topic in topics],
            textinfo="label+value+percent parent"
        ))
        
        fig.update_layout(
            title="News Topics Distribution",
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Topic sentiment analysis
        topic_sentiment = pd.DataFrame(topics)
        if not topic_sentiment.empty:
            st.subheader("Topic Sentiment Analysis")
            
            fig = go.Figure(go.Bar(
                x=topic_sentiment['topic'],
                y=topic_sentiment['sentiment'],
                marker_color=topic_sentiment['sentiment'].apply(self._get_sentiment_color)
            ))
            
            fig.update_layout(
                title="Sentiment by Topic",
                xaxis_title="Topic",
                yaxis_title="Sentiment Score",
                template='plotly_white'
            )
            
            st.plotly_chart(fig, use_container_width=True)
    
    def render_social_media_sentiment(self, sentiment_analysis):
        st.header("Social Media Sentiment")
        
        social = sentiment_analysis.get('social_sentiment', {})
        
        # Create radar chart
        fig = go.Figure()
        
        fig.add_trace(go.Scatterpolar(
            r=[
                social.get('twitter_sentiment', 0),
                social.get('reddit_sentiment', 0),
                social.get('stocktwits_sentiment', 0),
                social.get('youtube_sentiment', 0)
            ],
            theta=['Twitter', 'Reddit', 'StockTwits', 'YouTube'],
            fill='toself'
        ))
        
        fig.update_layout(
            polar=dict(
                radialaxis=dict(
                    visible=True,
                    range=[-1, 1]
                )
            ),
            title="Social Media Sentiment Analysis",
            template='plotly_white'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Social media metrics
        with st.expander("Social Media Metrics"):
            col1, col2 = st.columns(2)
            
            with col1:
                metrics = social.get('metrics', {})
                st.metric("Mention Volume", metrics.get('mention_volume', 0))
                st.metric("Engagement Rate", f"{metrics.get('engagement_rate', 0):.2%}")
            
            with col2:
                st.metric("Positive Mentions", metrics.get('positive_mentions', 0))
                st.metric("Negative Mentions", metrics.get('negative_mentions', 0))
    
    def _render_news_list(self, news_list):
        """Render a list of news articles."""
        for article in news_list:
            with st.expander(article['title']):
                st.write(article['description'])
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.caption(f"Source: {article['source']}")
                
                with col2:
                    st.caption(f"Published: {article['published_at']}")
                
                with col3:
                    sentiment = article.get('sentiment', 0)
                    st.progress(
                        (sentiment + 1) / 2,
                        text=f"Sentiment: {sentiment:.2f}"
                    )
    
    def _get_sentiment_trend(self, analysis):
        """Calculate sentiment trend."""
        trend = analysis['sentiment_trends'].get('trend', 0)
        return f"{trend:+.2f}" if trend != 0 else None
    
    def _get_sentiment_color(self, sentiment):
        """Get color based on sentiment score."""
        if sentiment > 0.33:
            return 'green'
        elif sentiment < -0.33:
            return 'red'
        return 'gray'
    
    def _filter_news_by_sentiment(self, news_data, sentiment_range):
        """Filter news articles based on sentiment range."""
        sentiment_values = {
            'Very Negative': -1.0,
            'Negative': -0.33,
            'Neutral': 0,
            'Positive': 0.33,
            'Very Positive': 1.0
        }
        
        min_sentiment = sentiment_values[sentiment_range[0]]
        max_sentiment = sentiment_values[sentiment_range[1]]
        
        return [
            article for article in news_data
            if min_sentiment <= article.get('sentiment', 0) <= max_sentiment
        ]

if __name__ == "__main__":
    news_page = NewsPage()
    news_page.run()

================
File: src/utils/__init__.py
================
from .cache import CacheManager, cache_market_data, cache_financial_data, cache_analysis
from .helpers import (
    DataProcessing,
    FormatHelper,
    TimeHelper,
    ValidationHelper,
    VisualizationHelper
)

__all__ = [
    'CacheManager',
    'cache_market_data',
    'cache_financial_data',
    'cache_analysis',
    'DataProcessing',
    'FormatHelper',
    'TimeHelper',
    'ValidationHelper',
    'VisualizationHelper'
]

================
File: src/utils/cache.py
================
import streamlit as st
from functools import wraps
from datetime import datetime, timedelta
import hashlib
import json
import pickle
from typing import Any, Callable, Dict, Optional

class CacheManager:
    """Manage caching of financial data and analysis results."""
    
    @staticmethod
    def hash_params(*args, **kwargs) -> str:
        """Create a hash of function parameters."""
        param_str = json.dumps({'args': args, 'kwargs': kwargs}, sort_keys=True)
        return hashlib.md5(param_str.encode()).hexdigest()

    @staticmethod
    def cache_data(ttl_seconds: int = 3600):
        """Cache decorator with time-to-live."""
        def decorator(func: Callable):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # Create cache key
                cache_key = f"{func.__name__}_{CacheManager.hash_params(*args, **kwargs)}"
                
                # Check cache
                if cache_key in st.session_state:
                    cached_data = st.session_state[cache_key]
                    if datetime.now() < cached_data['expiry']:
                        return cached_data['data']
                
                # Get fresh data
                data = func(*args, **kwargs)
                
                # Cache the result
                st.session_state[cache_key] = {
                    'data': data,
                    'expiry': datetime.now() + timedelta(seconds=ttl_seconds)
                }
                
                return data
            return wrapper
        return decorator

    @staticmethod
    def clear_cache(pattern: Optional[str] = None):
        """Clear cached data matching pattern."""
        if pattern:
            keys_to_clear = [
                key for key in st.session_state.keys()
                if pattern in key
            ]
        else:
            keys_to_clear = list(st.session_state.keys())
            
        for key in keys_to_clear:
            del st.session_state[key]

# Cache decorators
def cache_market_data(func):
    """Cache market data for 1 hour."""
    return CacheManager.cache_data(ttl_seconds=3600)(func)

def cache_financial_data(func):
    """Cache financial data for 24 hours."""
    return CacheManager.cache_data(ttl_seconds=86400)(func)

def cache_analysis(func):
    """Cache analysis results for 4 hours."""
    return CacheManager.cache_data(ttl_seconds=14400)(func)

================
File: src/utils/helpers.py
================
import pandas as pd
import numpy as np
from typing import Dict, Any, List, Union
import streamlit as st
from datetime import datetime, timedelta
import pytz

class DataProcessing:
    """Helper functions for data processing."""
    
    @staticmethod
    def clean_financials(df: pd.DataFrame) -> pd.DataFrame:
        """Clean financial data."""
        # Convert to numeric
        for col in df.select_dtypes(include=['object']).columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')
            
        # Fill missing values
        df.fillna(method='ffill', inplace=True)
        df.fillna(0, inplace=True)
        
        return df

    @staticmethod
    def calculate_returns(prices: pd.Series) -> pd.Series:
        """Calculate return series."""
        return prices.pct_change().fillna(0)

    @staticmethod
    def calculate_log_returns(prices: pd.Series) -> pd.Series:
        """Calculate logarithmic returns."""
        return np.log(prices / prices.shift(1)).fillna(0)

    @staticmethod
    def normalize_series(series: pd.Series) -> pd.Series:
        """Normalize series to 0-1 range."""
        return (series - series.min()) / (series.max() - series.min())

class FormatHelper:
    """Helper functions for formatting data."""
    
    @staticmethod
    def format_currency(value: float) -> str:
        """Format currency values."""
        if abs(value) >= 1e9:
            return f"${value/1e9:.1f}B"
        elif abs(value) >= 1e6:
            return f"${value/1e6:.1f}M"
        elif abs(value) >= 1e3:
            return f"${value/1e3:.1f}K"
        return f"${value:.2f}"

    @staticmethod
    def format_percentage(value: float) -> str:
        """Format percentage values."""
        return f"{value:.2f}%"

    @staticmethod
    def format_large_number(value: float) -> str:
        """Format large numbers."""
        if abs(value) >= 1e9:
            return f"{value/1e9:.1f}B"
        elif abs(value) >= 1e6:
            return f"{value/1e6:.1f}M"
        elif abs(value) >= 1e3:
            return f"{value/1e3:.1f}K"
        return f"{value:.0f}"

class TimeHelper:
    """Helper functions for time-related operations."""
    
    @staticmethod
    def get_market_hours() -> Dict[str, datetime]:
        """Get market hours in EST."""
        est = pytz.timezone('US/Eastern')
        now = datetime.now(est)
        market_open = now.replace(hour=9, minute=30, second=0, microsecond=0)
        market_close = now.replace(hour=16, minute=0, second=0, microsecond=0)
        
        return {
            'market_open': market_open,
            'market_close': market_close,
            'current_time': now
        }

    @staticmethod
    def is_market_open() -> bool:
        """Check if market is currently open."""
        hours = TimeHelper.get_market_hours()
        current = hours['current_time']
        
        # Check if it's a weekday
        if current.weekday() >= 5:
            return False
            
        return hours['market_open'] <= current <= hours['market_close']

    @staticmethod
    def time_to_market_close() -> timedelta:
        """Get time remaining until market close."""
        hours = TimeHelper.get_market_hours()
        if TimeHelper.is_market_open():
            return hours['market_close'] - hours['current_time']
        return timedelta(0)

class ValidationHelper:
    """Helper functions for data validation."""
    
    @staticmethod
    def validate_ticker(ticker: str) -> bool:
        """Validate ticker symbol."""
        if not ticker:
            return False
        return bool(ticker.strip().upper())

    @staticmethod
    def validate_date_range(start_date: datetime, end_date: datetime) -> bool:
        """Validate date range."""
        if not start_date or not end_date:
            return False
        return start_date < end_date

    @staticmethod
    def validate_numerical(value: Any) -> bool:
        """Validate numerical value."""
        try:
            float(value)
            return True
        except (ValueError, TypeError):
            return False

class VisualizationHelper:
    """Helper functions for data visualization."""
    
    @staticmethod
    def get_color_scheme() -> Dict[str, str]:
        """Get consistent color scheme."""
        return {
            'up': '#00C805',
            'down': '#FF3B69',
            'neutral': '#888888',
            'primary': '#1F77B4',
            'secondary': '#FF7F0E'
        }

    @staticmethod
    def get_timeframe_options() -> List[Dict[str, str]]:
        """Get standard timeframe options."""
        return [
            {'label': '1D', 'value': '1d'},
            {'label': '1W', 'value': '1wk'},
            {'label': '1M', 'value': '1mo'},
            {'label': '3M', 'value': '3mo'},
            {'label': '1Y', 'value': '1y'},
            {'label': '5Y', 'value': '5y'}
        ]

    @staticmethod
    def create_candlestick_figure(data: pd.DataFrame, 
                                include_volume: bool = True) -> Dict[str, Any]:
        """Create standard candlestick chart configuration."""
        import plotly.graph_objects as go
        
        fig = go.Figure()
        
        # Candlestick
        fig.add_trace(go.Candlestick(
            x=data.index,
            open=data['Open'],
            high=data['High'],
            low=data['Low'],
            close=data['Close'],
            name='OHLC'
        ))
        
        # Volume
        if include_volume and 'Volume' in data.columns:
            fig.add_trace(go.Bar(
                x=data.index,
                y=data['Volume'],
                name='Volume',
                yaxis='y2'
            ))
            
            fig.update_layout(
                yaxis2=dict(
                    title='Volume',
                    overlaying='y',
                    side='right'
                )
            )
        
        fig.update_layout(
            height=600,
            xaxis_rangeslider_visible=False,
            template='plotly_white'
        )
        
        return fig
